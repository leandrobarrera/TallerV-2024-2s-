/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 02/02/2025
 *
 *
 ******************************************************************************


 =========================================================     M A Z E R U N N E R     ========================================================================


 */
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "systick_driver_hal.h"
#include "main.h"
#include "usart_driver_hal.h"
#include "adc_driver_hal.h"
#include "i2c_driver_hal.h"
#define HSI_CLOCK_CONFIGURED				0				// 16 MHz
#define BUFFER_SIZE 						64

//Handlers GPIO, para los pines. Lo de toda la vida.
GPIO_Handler_t userLed = {0}; 	//	PinH1
GPIO_Handler_t LedA = {0}; 		//	PinB12
GPIO_Handler_t LedB = {0}; 		//	PinA12
GPIO_Handler_t LedC = {0}; 		//	PinC11
GPIO_Handler_t LedD = {0}; 		//	PinC10
GPIO_Handler_t LedE = {0};		//	PinC12
GPIO_Handler_t LedF = {0};		//	PinA11
GPIO_Handler_t LedG = {0}; 		//	PinD2




//variables

uint8_t flag_usart = 0;		//bandera para el usart
uint8_t switcheo = 0; 		//variable para hacer switch de los transistores.
uint16_t valX = 0;			//valor adc del pinX
uint16_t valY = 0;			//valor adc del pinY
uint16_t adc_data = 0;		//data del adc
int8_t posX = 0;			//posicion en X pantalla
int8_t posY = 0;			//posicion en Y pantalla


int conteo_ms = 0;		//variable para guardar el conteo de ms del systick

//variables para USART6
USART_Handler_t commSerial={0};
GPIO_Handler_t pinTx ={0};
GPIO_Handler_t pinRx ={0};
uint8_t receivedChar = 	'\0';
uint8_t sendMsg = 0;
char bufferData[64] = {0};
char bufferReception[BUFFER_SIZE];
char userMsg[BUFFER_SIZE] = {0};
char cmd[16];
uint32_t firstParameter;
uint32_t secondParameter;
uint8_t counterReception;



//GPIO Handlers

GPIO_Handler_t pinRX = {0}; //	PinA0
GPIO_Handler_t pinTX = {0}; //	PinA0
GPIO_Handler_t pinX = {0}; //	PinA0
GPIO_Handler_t pinY = {0}; //	PinA0






//Handlers para los timers

Timer_Handler_t blinkyTimer = {0};




//Maquina de estados finito :D
fsm_states_t fsm_program  = {0};



/*
 * The main function, where EVERYTHING HAPPENS. The magic happens...
 */



void init_system(void);
extern void configMagic(void);
FSM_STATES fsm_function(uint8_t evento);
void lecturaXY(void);
void procesar_coordenadas (void);


int main(void)
{
	init_system();
	config_SysTick_ms(0);
	configMagic();



	//Configurando el Systick
	config_SysTick_ms(HSI_CLOCK_CONFIGURED);

	while(1){

		fsm_function(fsm_program.state);


		}

	}


void init_system(void){
	/*	Configuramos los pines*/

	/*	LedBlinky	*/
	userLed.pGPIOx 							= 	GPIOH;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_1;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);

	/*	PinX	*/
	pinX.pGPIOx 							= 	GPIOH;
	pinX.pinConfig.GPIO_PinNumber		=	PIN_1;
	pinX.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	pinX.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	pinX.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	pinX.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&pinX);

	gpio_WritePin(&pinX, SET);

	/*	PinY	*/
	pinY.pGPIOx 							= 	GPIOH;
	pinY.pinConfig.GPIO_PinNumber		=	PIN_1;
	pinY.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	pinY.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	pinY.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	pinY.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&pinY);

	gpio_WritePin(&pinY, RESET);


	/* Configuramos el ADC */

	//el joystick esta en el canal0, usamos las configs que el profe nos dejo

	joystick.channel = CHANNEL_0;
	joystick.resolution = RESOLUTION_12_BIT;
	joystick.dataAlignment = ALIGNMENT_RIGHT;
	joystick.interruptState = ADC_INT_ENABLE;
	joystick.samplingPeriod = SAMPLING_PERIOD_112_CYCLES;

	//cargamos la config.
	adc_ConfigSingleChannel(&joystick);
	adc_StartSingleConv();











	/*esto es lo nuevo, esta forma de cargar las configuraciones de los Handlers de los timers es parecida a
	 * los del GPIO, la primera fila para definir el que queremos usar (quedan a eleccion del programador) no obstante
	 * en la tarea se nos pide que usemos ciertos timers con cierto numero especifico de bits, 32 para unos y 16 para otros.
	 * Por tanto se uso esta escogencia. En la segunda fila del prescaler se usa el 16000 para que durante todo este
	 * proceso de interrupciones, y teniendo que el micro va a 16MHz, el 16000 divide esta cifra y la deja en un formato de
	 * 1 ms. Este 1 ms se multiplica por el periodo, y lo elegimos segun lo que requiramos. Para el TIM2 pusimos 1000
	 * que 1ms * 1000, nos da 1000ms lo que es igual a 1 segundo, lo que completa nuestro deseo que este contador de segundos
	 * en efecto, cuente segundos. Para el blinky de manera "estandar" hacemos que vaya a un ratio de 250 ms.
	 */

	blinkyTimer.pTIMx 							= TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period			=250;  //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */

	/*Cuenta regresiva */

	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer,SET);

	display.pTIMx 								= TIM3;
	display.TIMx_Config.TIMx_Prescaler			=16000;  //	Genera incrementos de 1ms
	display.TIMx_Config.TIMx_Period				=2;  //	60FPS ultra calidad gamer. Se tuvo que subir porque no se veÃ­a fluido el refresco, antes era 15, que significaban 60 FPS
	display.TIMx_Config.TIMx_mode				=TIMER_UP_COUNTER;  //
	display.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&display);

	//	Encedemos el Timer.
	timer_SetState(&display,SET);






	fsm_program.state = STATE_IDLE;

	/* Configuramos los pines del puerto serial
	 * pin sobre el que funciona el USART6 (TX) */

	pinTx.pGPIOx                          = GPIOC;
	pinTx.pinConfig.GPIO_PinNumber        = PIN_6;
	pinTx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode	  = AF8;
	pinTx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinTx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinTx);

	/* Pin sobre el que funciona el USART2 (RX) */

	pinRx.pGPIOx                          = GPIOC;
	pinRx.pinConfig.GPIO_PinNumber        = PIN_7;
	pinRx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode	  = AF8;
	pinRx.pinConfig.GPIO_PinOutputType    = GPIO_OTYPE_PUSHPULL;
	pinRx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinRx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinRx);



	//Configuramos el puerto serial (USART2)
	commSerial.ptrUSARTx				= USART6;
	commSerial.USART_Config.baudrate    = USART_BAUDRATE_115200;
	commSerial.USART_Config.datasize	= USART_DATASIZE_8BIT;
	commSerial.USART_Config.parity		= USART_PARITY_NONE;
	commSerial.USART_Config.stopbits	= USART_STOPBIT_1;
	commSerial.USART_Config.mode 		= USART_MODE_RXTX;
	commSerial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;

	/* Escribimos la configuracion en la memoria del MCU */
	usart_Config(&commSerial);

	usart_WriteChar(&commSerial, '\0');






}



/*
 *  Overwrite function
 **/



void analizeRecievedChar(void){
	if(commSerial.receivedChar !='\0'){
		bufferReception[counterReception] = commSerial.receivedChar;
		counterReception++;

		if (commSerial.receivedChar == '@'){
			bufferReception[counterReception] = '\0';
			counterReception = 0;
			fsm_program.state = STATE_COMMAND_COMPLETE;
		}
	}
}

/* Funcion encargada de almacenar los valores de adc para el joystick, con esto switcheamos para que sea posible
 * la lectura de los valores en la coordenada X y Y, se usaran mosfets para un switcheo mas rapido.
 * Importante saber que los pines asignados empiezan uno en set y otro en reset.
 */

void lecturaXY(void){

	switch(switcheo){

	case 0:{

		adc_StartSingleConv();
		valX = adc_data;

	}
	case 1:{

		adc_StartSingleConv();
		valY = adc_data;
	}
	}

	if(switcheo = 0){

		switcheo = 1;

	}

	else{

		switcheo = 0;

	}

	gpio_TooglePin(&pinX);
	gpio_TooglePin(&pinY);

}

/* Funcion para hacer efectivo el movimiento del joystick en la pantalla, recordar que el adc tiene holgura
 * entonces los valores tienen que ser tenidos en cuenta en rangos.
 */

void procesar_coordenadas(void){

	if(valX > 3040 && ValX < 4096){

		posX = posX +1;
	}

	if(valY > 3040 && ValY < 4096){

			posY = posY +1;
		}

	if(valX > 0 && ValX < 1040){

			posX = posX -1;
		}

	if(valY > 0 && ValY < 1040){

				posY = posY -1;
			}
}














FSM_STATES fsm_function(uint8_t evento){

	switch(evento){
	case STATE_IDLE:{


		break;
	}
	case STATE_MODO_RGB:{

		printf("SW\n");
		printf("ms: %d\n", conteo_ms);



		fsm_program.state = STATE_IDLE;
		break;
	}

	case STATE_GIRO_ENCODER:{

		fsm_program.state = STATE_IDLE;
		break;

	}

	case STATE_REFRESH_DISPLAY:{

		fsm_program.state = STATE_IDLE;
		break;
	}

	case STATE_CHAR_RECEIVED:{
		fsm_program.state = STATE_IDLE;


			break;

	}

	case STATE_COMMAND_COMPLETE:{
		break;
	}
		default: {
		fsm_program.state = STATE_IDLE;
		break;
	}
	}
	return 	fsm_program.state;

}





/* en este callback se sube y baja la bandera (UIF) permitiendo que se de la interrupcion y no quede
 * interrumpido indefinidamente, al mismo tiempo siendo este el timer que usamos para nuestro contador de segundos
 * hacemos que durante esta interrupcion (de 1 seg, valga la redundancia) se nos sume a una variable auxiliar que llamamos
 * contador, que es la que nos ayuda en la parte del codigo del display, para ir mostrando los numeros en el momento que
 * necesitamos. Es decir cuando se hace la interrupcion, esta misma (administrada por el timer2) suma +1 al contador.
 * Esta parte del codigo ademas de mandar la interrupcion, tambien detiene la misma.
 */





//sube la bandera del display
void Timer3_Callback(void){
	fsm_program.state = STATE_REFRESH_DISPLAY;
}

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que nos sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.

 Ademas de eso, agregamos la bandera para que se de la conversion de adc y la inicializacion de la variable sendMsg*/
void Timer5_Callback(void){
	gpio_TooglePin(&userLed);

}


// Callback de ADC. adcData recibe el valor del adc. Subimos la bander del adc.
void adc_CompleteCallback (void){
	adc_data = adc_GetValue();
	flag_adc = 1;

}

void usart6_RxCallback(void){
	fsm_program.state = STATE_CHAR_RECEIVED;
	receivedChar = usart_getRxData(&commSerial);
}


/*
 *  Esta funcion sirve para detectar problemas de parametros
 *  incorrectos al momento de ejecutar un programa.
   */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		//problems...
	}
}
